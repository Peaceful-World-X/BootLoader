
<p align="center">
  <img src="https://i-blog.csdnimg.cn/direct/d41d8cd98f00b204e9800998ecf8427e.svg" alt="Logo" width="150"/>
</p>

<h1 align="center" style="font-size: 32px;">⚙️ BootLoader - 嵌入式固件升级利器
  <a href="https://github.com/Peaceful-World-X/BootLoader/releases/latest" download>点击下载⚡</a>
</h1>

🚀 **BootLoader** 是基于 Qt 6 的嵌入式固件升级工具，支持**串口/网口双模式**、**多设备支持**（ARM/FPGA/DSP）、**实时进度显示**和**智能错误恢复**，让嵌入式系统固件升级变得简单、可靠、高效！

## 🥳 主要功能

✨ **双通信模式** - 灵活支持 **RS232/USB-TTL 串口** 和 **TCP 网口** 两种通信方式，满足不同硬件环境需求，自动端口检测，一键连接！

✨ **多设备支持** - 全面兼容 **ARM**、**FPGA**、**DSP1**、**DSP2** 四大设备类型，单一工具完成多种设备升级，降低学习成本！

✨ **实时进度显示** - 升级过程中精确显示**数据传输进度**、**当前状态**和**详细日志**，让你清楚掌握升级动态！

✨ **完整协议支持** - 基于标准 **BootLoader 协议**（0xAA/0x55 包头），支持**请求、命令、数据、结束** 全流程报文，兼容各种嵌入式固件规范！

✨ **智能重试机制** - 内置**自动超时检测**和**错误重传**，确保升级的稳定性，即使网络波动也能可靠完成！

✨ **详细日志记录** - 完整的**发送/接收日志**、**通信时间戳**、**错误信息追踪**，便于问题排查和性能分析！

## 🤪 软件使用

🟢 **绿色免安装**，下载即用，支持 Windows 平台！

### 快速开始三步走

#### 1️⃣ 选择通信模式与端口
- **串口模式**：自动检测系统中所有可用串口，选择对应的 COM 口
- **网口模式**：输入目标设备的 IP 地址和端口号
- 实时显示连接状态，绿灯表示连接成功

#### 2️⃣ 加载固件文件
- 点击"浏览"按钮选择要升级的 **.bin** 或 **.hex** 固件文件
- 显示文件大小和文件路径，确保加载正确
- 支持 FPGA、ARM、DSP 等多种固件格式

#### 3️⃣ 执行升级
- 选择目标设备类型（ARM/FPGA/DSP1/DSP2）
- 点击"开始升级"按钮，稍后片刻即可完成
- 升级完成后自动重启设备，升级过程全程显示

<p align="center">
  <img src="https://i-blog.csdnimg.cn/direct/placeholder_main_interface.png" alt="主界面" width="80%"/>
</p>

<p align="center">
  <em>BootLoader 主界面 - 清爽简洁的升级体验</em>
</p>

### 高级功能详解

#### 📝 实时日志窗口
- **独立日志面板**：实时显示通信过程中的所有数据帧
- **时间戳记录**：精确到毫秒级的时间标记
- **颜色区分**：发送数据（蓝色）和接收数据（绿色）一目了然
- **快速操作**：支持日志的暂停、保存、清空

#### 🔧 手动命令发送
- 调试模式下可以手动发送自定义命令
- 支持**十六进制**和**文本** 两种输入格式
- 实时查看设备响应，完美的协议调试工具

#### ⚙️ 详细配置选项
- **波特率**：115200、57600、19200 等多种选择
- **连接超时**：可自定义超时时间（单位秒）
- **重试次数**：智能重试机制，失败自动重新尝试
- **日志级别**：标准模式、详细模式、调试模式三级选择

## 🎯 核心特色深度解析

### 🔥 完整的BootLoader协议实现

BootLoader 遵循业界标准的固件升级协议，包括：

**报文结构**（上位机发送）：
```
┌─────┬─────┬──────────┬──────┬──────┬──────┬──────┬───────────┬─────┐
│0xAA │ 0x55│ Device ID│ Len_H│ Len_L│ Type │ Ack  │ Data[n]   │ CRC │
└─────┴─────┴──────────┴──────┴──────┴──────┴──────┴───────────┴─────┘
 包头1 包头2  设备标识  长度高 长度低 功能码 应答码 命令数据  CRC校验
```

**功能码定义**（共16种）：
- `0x01`：升级请求（系统控制）
- `0x03-0x05`：ARM 设备升级（命令/数据/结束）
- `0x06-0x09`：FPGA 设备升级（命令/数据/结束）
- `0x0A-0x0C`：DSP1 设备升级（命令/数据/结束）
- `0x0D-0x0F`：DSP2 设备升级（命令/数据/结束）
- `0x10`：总体结束（系统命令）

**应答标识**（23种状态码）：
- `0x00`：执行成功
- `0x02`：数据校验错误
- `0x04`：允许升级
- `0x0A`：Flash 擦除成功
- `0x0E`：升级完成
- ...等更多状态

### 🧠 智能通信引擎

**自动流程控制**：
- 自动检测设备是否在线
- 自动获取设备状态信息
- 自动进行数据分片传输
- 自动校验每个数据包的完整性
- 自动处理升级中断和恢复

**容错能力强大**：
- 单个数据包失败时自动重传
- 多次失败自动降速重试
- 通信超时时自动中断并提示用户
- 支持升级中断后的恢复继续

### ⚡ 高效数据传输

**分片传输机制**：
- 大文件自动切割为多个数据包
- 每个数据包 **1024 字节** 的最优大小
- CRC-MODBUS 校验确保数据完整性
- 支持高达 **256MB** 固件文件升级

**性能优化**：
- 基于事件驱动的异步传输
- 非阻塞式 UI 更新，升级过程不卡顿
- 动态缓冲区管理，内存占用最小化

### 🌐 双网络模式完美支持

**串口模式优势**：
- 通用性强，几乎所有设备都支持
- 工业级可靠性，抗干扰能力强
- 适合生产线升级

**网口模式优势**：
- 传输速率快，升级时间短
- 支持远程升级，无需物理接近设备
- 适合现代物联网场景

## 🤗 代码编译

### 系统要求
- **Qt 版本**：6.8.1 或更高版本
- **编译器**：MinGW 64-bit（推荐）或 MSVC 2019+
- **操作系统**：Windows 10/11
- **C++ 标准**：C++17 或更高

### 一键编译方法

#### 方法一：使用 Qt Creator（推荐）
```
1. 下载并安装 Qt 6.8.1 及 Qt Creator
2. 打开 BootLoader.pro 项目文件
3. 选择编译套件 → MinGW 64-bit + Qt 6.8.1
4. 点击"构建"按钮（Ctrl+B）
5. 在 build/ 目录找到生成的 BootLoader.exe
```

#### 方法二：命令行编译
```bash
git clone https://github.com/Peaceful-World-X/BootLoader.git
cd BootLoader
qmake BootLoader.pro
mingw32-make release
# 可执行文件输出到 bin/ 目录
```

#### 方法三：使用 CMake（高级用户）
```bash
mkdir build && cd build
cmake ..
make -j4
```

✨ **编译出问题？** 常见问题排查：
- ❌ 找不到 Qt 路径 → 检查环境变量 `QTDIR` 是否设置
- ❌ 编译错误 C++版本不对 → 确保编译器支持 C++17
- ❌ 链接失败 → 清除 build 目录重新编译

## 🧪 功能测试

### 内置测试工具

项目提供两个 Python 测试脚本，**无需实际硬件** 即可测试所有功能！

#### 测试环境搭建
```bash
# 安装 Python 3.8+
pip install pyserial  # 用于串口测试
# 网口测试无需额外依赖
```

#### TCP 网口测试 (`test_TCP.py`)
```python
# 模拟一个 TCP 网络设备
python test_TCP.py
# 默认监听 192.168.1.100:5000
# BootLoader 中配置相同 IP 和端口即可连接
```

**测试流程**：
1. 运行 `test_TCP.py` 启动模拟设备
2. BootLoader 选择"网口模式"
3. 输入 IP `192.168.1.100` 和端口 `5000`
4. 加载固件文件并点击"开始升级"
5. 观察日志窗口的通信过程

#### 串口测试 (`test_COM.py`)
```python
# 模拟一个串口设备（需要虚拟串口工具）
# 推荐使用 com0com 或 Virtual Serial Port Driver
python test_COM.py --port COM1 --baudrate 115200
```

**虚拟串口配置**（Windows）：
1. 安装 `com0com` 工具（免费）
2. 配置虚拟串口对 COM1 ↔ COM2
3. BootLoader 连接 COM1
4. 测试脚本运行在 COM2
5. 模拟各种故障场景进行压力测试

## 💡 实战应用场景

### 场景一：产线自动化升级

**需求**：为 100 台 ARM 设备批量升级固件

**解决方案**：
```
1. 将所有设备通过 USB-TTL 转接器连接到一台电脑
2. BootLoader 连接第一台设备
3. 升级成功后断开重连下一台设备
4. 通过脚本自动化这个过程（已提供 test 脚本参考）
```

### 场景二：远程 IoT 设备升级

**需求**：升级分布在各地的 IoT 网关设备

**解决方案**：
```
1. 使用"网口模式"，输入设备 IP 地址
2. 支持 NAT/VPN 穿透的 IP 地址
3. 一个工具管理所有地域的设备升级
4. 升级日志自动保存用于审计
```

### 场景三：嵌入式开发调试

**需求**：快速迭代固件开发和测试

**解决方案**：
```
1. 编写完新固件代码后立即编译
2. 点击"开始升级"一键加载到目标设备
3. 观察串口输出验证功能
4. 修改代码后重复上述过程
5. 充分利用日志功能定位问题
```

## 🎓 协议详解（深度阅读）

### 升级流程时序图

```
上位机                        下位机
  │                            │
  ├──────请求升级 (0x01)──────>│
  │                            │
  │<─────回复允许 (0x04)────────┤
  │                            │
  ├──ARM 命令 (0x03)───────────>│
  │                            │
  │<────命令应答 (0x03)─────────┤
  │                            │
  ├─ARM 数据1 (0x04)──────────>│
  ├─ARM 数据2 (0x04)──────────>│
  │       ...                  │
  │<────数据应答 (0x04)─────────┤
  │                            │
  ├──ARM 结束 (0x05)──────────>│
  │                            │
  │<────结束应答 (0x05)─────────┤
  │                            │
  ├──总体结束 (0x10)──────────>│
  │                            │
  │<────结束应答 (0x10)─────────┤
  │                            ├─ 重启设备
  │                            │
```

### 错误处理与恢复

| 错误类型 | 应答码 | 处理策略 |
|---------|--------|---------|
| 数据校验错误 | 0x02 | 重新传输当前数据包 |
| 接收超时 | 0x03 | 重新发送上一条命令 |
| 禁止升级 | 0x05 | 停止升级，显示设备状态 |
| Flash 擦除失败 | 0x0B | 重试擦除操作 |
| 数据大小错误 | 0x0F | 检查固件文件完整性 |

## 🚀 进阶技巧

### 🎯 批量升级脚本开发

基于 BootLoader 的协议规范，可以开发自动化脚本：

```python
# 示例：Python 自动化升级脚本框架
import serial
import struct

class BootLoaderClient:
    def __init__(self, port, baudrate=115200):
        self.ser = serial.Serial(port, baudrate, timeout=10)
    
    def send_command(self, msg_type, data=b''):
        # 构建报文
        header = b'\xAA\x55'
        device_id = b'\x01'
        length = len(data) + 3
        length_bytes = struct.pack('>H', length)
        msg_type_byte = bytes([msg_type])
        ack = b'\xFE'
        
        # CRC 校验
        payload = header + device_id + length_bytes + msg_type_byte + ack + data
        crc = self.calculate_crc(payload)
        frame = payload + struct.pack('>H', crc)
        
        self.ser.write(frame)
        return self.wait_response(msg_type)
    
    def calculate_crc(self, data):
        # CRC-MODBUS 算法
        crc = 0xFFFF
        for byte in data:
            crc ^= byte
            for _ in range(8):
                if crc & 1:
                    crc = (crc >> 1) ^ 0xA001
                else:
                    crc >>= 1
        return crc
    
    def wait_response(self, expected_type):
        # 接收响应报文
        while True:
            data = self.ser.read(7)  # 读取固定头
            if len(data) < 7:
                continue
            # 解析并验证报文
            # ... 解析逻辑 ...
            return True

# 使用示例
client = BootLoaderClient('COM3')
client.send_command(0x01)  # 请求升级
client.send_command(0x03, open('firmware.bin', 'rb').read())  # 发送固件
```

### 💾 升级记录与分析

每次升级都会生成详细的日志文件，格式如下：

```
[2025-11-12 10:30:45.123] 连接设备: COM3 (115200 bps)
[2025-11-12 10:30:46.001] 发送: AA 55 01 00 0E 01 FE ... (0xABCD)
[2025-11-12 10:30:46.150] 接收: 55 AA 01 00 06 01 04 ... (0x1234)
[2025-11-12 10:30:46.151] 允许升级，开始数据传输
[2025-11-12 10:30:46.200] 数据包 1/256: 1024 字节
...
[2025-11-12 10:31:02.900] 升级完成，总耗时 17.8 秒
[2025-11-12 10:31:03.100] 设备重启成功
```

## 📊 性能指标

| 指标项 | 数值 | 说明 |
|-------|------|------|
| 最大支持固件大小 | 256 MB | 受设备 Flash 限制 |
| 串口速率 | 115200 bps | 可配置，支持多种速率 |
| 网口速率 | 100 Mbps | 本地网络可达 |
| 最大升级时间 | <2 分钟 | 1MB 固件大小（网口模式） |
| 最小升级时间 | <5 分钟 | 1MB 固件大小（串口模式） |
| CRC 校验正确率 | 100% | CRC-MODBUS 算法保证 |
| 超时重试机制 | 3 次 | 可配置重试次数 |

## 🎉 项目架构

```
BootLoader
├── 通信层 (Communication)
│   ├── 串口通信 (Serial Port)
│   └── TCP 网口通信 (TCP Network)
│
├── 协议层 (Protocol)
│   ├── 报文编码
│   ├── 报文解析
│   └── CRC 校验
│
├── 业务层 (Upgrade Logic)
│   ├── 升级状态机
│   ├── 流程控制
│   └── 错误处理
│
└── 表现层 (UI)
    ├── 主窗口
    ├── 日志显示
    └── 实时进度
```

## 💬 常见问题解答

**Q: BootLoader 支持哪些操作系统？**
A: 当前版本支持 Windows 10/11。Linux 和 macOS 版本在规划中，敬请期待！

**Q: 如何处理升级失败的情况？**
A: 查看日志窗口的错误信息，常见的有：
- 通信超时：检查串口/网络连接
- 数据校验错误：检查固件文件是否损坏
- 设备禁止升级：可能需要解锁设备

**Q: 能否升级多台设备？**
A: 可以。每次升级一台设备，支持通过脚本自动循环。

**Q: 升级过程中断电会怎样？**
A: 设备可能会进入异常状态。通常重启设备后重新升级即可恢复。

**Q: 日志文件保存在哪里？**
A: 默认保存在程序同级目录的 `bootloader.log` 文件。

## 🤝 贡献指南

欢迎提交 Issue 和 Pull Request！

- 🐛 发现 bug？提交 Issue 描述问题
- 💡 有新功能建议？开讨论 Discussion
- 🔧 想要贡献代码？Fork 后提交 PR

## 📄 许可证

本项目采用 MIT 许可证，详见 LICENSE 文件。

---

**🎊 感谢使用 BootLoader！如果有帮助，请点个 Star 支持我们！**

> 最后更新：2025-11-12
> GitHub: https://github.com/Peaceful-World-X/BootLoader
